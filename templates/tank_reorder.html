{% extends "base.html" %}
{% block content %}
<div class="d-flex flex-wrap align-items-center justify-content-between mb-4 gap-3">
  <div>
    <h1 class="h3 mb-0 fw-bold">Reorder Tanks</h1>
    <div class="text-muted small">Drag tanks to change their dashboard order.</div>
  </div>
  <a class="btn btn-outline-secondary" href="/">
    <i class="bi bi-arrow-left"></i> Back to Dashboard
  </a>
</div>

<div class="card shadow-sm">
  <div class="card-body">
    <ul class="list-group" id="tankOrderList">
      {% for t in tanks %}
        <li class="list-group-item d-flex align-items-center gap-3 tank-drag-item" draggable="true" data-tank-id="{{ t.id }}">
          <span class="text-muted"><i class="bi bi-grip-vertical"></i></span>
          <span class="fw-semibold">{{ t.name }}</span>
        </li>
      {% endfor %}
    </ul>
  </div>
</div>

<div class="mt-3 d-flex justify-content-end">
  <button class="btn btn-primary" id="saveOrder">Save Order</button>
</div>

<style>
  .tank-drag-item {
    touch-action: none;
  }
</style>

<script>
  const list = document.getElementById("tankOrderList");
  const saveButton = document.getElementById("saveOrder");
  let dragging = null;
  let touchDragging = false;
  let activePointerId = null;

  const moveDraggedItem = (clientY, clientX = window.innerWidth / 2) => {
    const candidates = document.elementsFromPoint(clientX, clientY);
    const target = candidates
      .map((candidate) => candidate.closest?.("[data-tank-id]"))
      .find((item) => item && item !== dragging);
    if (!target || target === dragging) return;
    const rect = target.getBoundingClientRect();
    const next = (clientY - rect.top) / rect.height > 0.5;
    list.insertBefore(dragging, next ? target.nextSibling : target);
  };

  list.addEventListener("dragstart", (event) => {
    dragging = event.target.closest("[data-tank-id]");
    if (dragging) {
      dragging.classList.add("opacity-50");
    }
  });

  list.addEventListener("dragend", () => {
    if (dragging) {
      dragging.classList.remove("opacity-50");
      dragging = null;
    }
  });

  list.addEventListener("dragover", (event) => {
    event.preventDefault();
    moveDraggedItem(event.clientY, event.clientX);
  });

  list.addEventListener("pointerdown", (event) => {
    if (event.pointerType !== "touch") return;
    dragging = event.target.closest("[data-tank-id]");
    if (!dragging) return;
    touchDragging = true;
    activePointerId = event.pointerId;
    dragging.classList.add("opacity-50");
    dragging.setPointerCapture(activePointerId);
    event.preventDefault();
  });

  list.addEventListener("pointermove", (event) => {
    if (!touchDragging || event.pointerId !== activePointerId) return;
    event.preventDefault();
    moveDraggedItem(event.clientY, event.clientX);
  });

  const endTouchDrag = () => {
    if (!touchDragging) return;
    if (dragging) {
      dragging.classList.remove("opacity-50");
      if (activePointerId !== null) {
        dragging.releasePointerCapture(activePointerId);
      }
    }
    dragging = null;
    touchDragging = false;
    activePointerId = null;
  };

  list.addEventListener("pointerup", (event) => {
    if (event.pointerId !== activePointerId) return;
    event.preventDefault();
    endTouchDrag();
  });
  list.addEventListener("pointercancel", (event) => {
    if (event.pointerId !== activePointerId) return;
    event.preventDefault();
    endTouchDrag();
  });

  list.addEventListener(
    "touchstart",
    (event) => {
      const touch = event.touches[0];
      if (!touch) return;
      dragging = event.target.closest("[data-tank-id]");
      if (!dragging) return;
      touchDragging = true;
      activePointerId = null;
      dragging.classList.add("opacity-50");
      event.preventDefault();
    },
    { passive: false }
  );

  list.addEventListener(
    "touchmove",
    (event) => {
      if (!touchDragging) return;
      const touch = event.touches[0];
      if (!touch) return;
      moveDraggedItem(touch.clientY, touch.clientX);
      event.preventDefault();
    },
    { passive: false }
  );

  list.addEventListener(
    "touchend",
    (event) => {
      if (!touchDragging) return;
      event.preventDefault();
      endTouchDrag();
    },
    { passive: false }
  );

  list.addEventListener(
    "touchcancel",
    (event) => {
      if (!touchDragging) return;
      event.preventDefault();
      endTouchDrag();
    },
    { passive: false }
  );

  list.addEventListener("contextmenu", (event) => {
    if (event.target.closest(".tank-drag-item")) {
      event.preventDefault();
    }
  });

  saveButton.addEventListener("click", async () => {
    const order = Array.from(list.querySelectorAll("[data-tank-id]")).map((item) => item.dataset.tankId);
    const response = await fetch("/tanks/order", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-CSRF-Token": window.csrfToken || "",
      },
      body: JSON.stringify({ order })
    });
    if (response.ok) {
      saveButton.textContent = "Saved!";
      setTimeout(() => { saveButton.textContent = "Save Order"; }, 1500);
    }
  });
</script>
{% endblock %}
